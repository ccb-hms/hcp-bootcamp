---
title: "Summarizing and Visualizing data"
format: 
  html: default
code-annotations: select
---

## Dataframes

We will begin with a mostly processed dataset from NHANES designed to examine the relationship between diabetes and dental caries in adolescents. Specifically, this dataset contains the 3346 adolescents recorded in NHANES from 2005 to 2010 with non-missing dental decay data.

We can load the data into R as a dataframe using the `read.csv` function. 

```{r}
library(tidyverse)
library(DT)

nhanes <- read.csv("https://raw.githubusercontent.com/ccb-hms/hsdm-r-course/main/session-materials/session0/session0Data.csv")
```

This statement doesn't produce any output because, as you might
recall, assignments don't display anything. If we want to check that
our data has been loaded, we can see the contents of the data frame by
typing its name:

```{r, eval=FALSE}
nhanes
```

Wow... that was a lot of output. At least it means the data loaded
properly. Let's check the top (the first 6 lines) of this data frame
using the function `head()`:

```{r, purl=TRUE}
head(nhanes)
```

Data frames are the *de facto* data structure for most tabular data,
and what we use for statistics and plotting.

A data frame can be created by hand, but most commonly they are
generated by the functions `read.csv()` or `read.table()`; in other
words, when importing spreadsheets from your hard drive (or the web).

A data frame is the representation of data in the format of a table
where the columns are vectors that all have the same length. Because
columns are vectors, each column must contain a single type of data
(e.g., characters, integers, factors).

We can see this when inspecting the <b>str</b>ucture of a data frame
with the function `str()`:

```{r}
str(nhanes)
```

## Inspecting `data.frame` Objects

We already saw how the functions `head()` and `str()` can be useful to
check the content and the structure of a data frame. Here is a
non-exhaustive list of functions to get a sense of the
content/structure of the data. Let's try them out!

**Size**:

- `dim(nhanes)` - returns a vector with the number of rows as the first
  element, and the number of columns as the second element (the
  **dim**ensions of the object).
- `nrow(nhanes)` - returns the number of rows.
- `ncol(nhanes)` - returns the number of columns.

**Content**:

- `head(nhanes)` - shows the first 6 rows.
- `tail(nhanes)` - shows the last 6 rows.

**Names**:

- `names(nhanes)` - returns the column names (synonym of `colnames()` for
  `data.frame` objects).
- `rownames(nhanes)` - returns the row names.

**Summary**:

- `str(nhanes)` - structure of the object and information about the
  class, length and content of each column.
- `summary(nhanes)` - summary statistics for each column.

Note: most of these functions are "generic", they can be used on other types of
objects besides `data.frame`.

## Loading data with tidyverse

Instead of `read.csv()`, we will read in our data using the `read_csv()`
function (notice the `_` instead of the `.`), from the tidyverse package
**`readr`**.

```{r, message=FALSE, purl=TRUE}
nhanes <- read_csv("https://raw.githubusercontent.com/ccb-hms/hsdm-r-course/main/session-materials/session0/session0Data.csv")

## view the data
datatable(nhanes)
```

Notice that the class of the data is now referred to as a "tibble".

Tibbles tweak some of the behaviors of the data frame objects we introduced in the
previously. The data structure is very similar to a data frame. For our purposes
the only differences are that:

1. It displays the data type of each column under its name.
  Note that \<`dbl`\> is a data type defined to hold numeric values with
  decimal points.

2. It only prints the first few rows of data and only as many columns as fit on
  one screen.

We are now going to learn some of the most common **`dplyr`** functions:

- `select()`: subset columns
- `filter()`: subset rows on conditions
- `mutate()`: create new columns by using information from other columns
- `group_by()` and `summarise()`: create summary statistics on grouped data
- `arrange()`: sort results
- `count()`: count discrete values

## Selecting columns and filtering rows

To select columns of a data frame, use `select()`. The first argument
to this function is the data frame (`nhanes`), and the subsequent
arguments are the columns to keep.

```{r, purl=TRUE}
select(nhanes, sex, age.years, dental.decay.present, hba1c)
```

To select all columns *except* certain ones, put a "-" in front of
the variable to exclude it.

```{r, purl=TRUE}
select(nhanes, -sequence.id, -family.PIR)
```

This will select all the variables in `nhanes` except `sequence.id`
and `family.PIR`.

To choose rows based on a specific criteria, use `filter()`:

```{r, purl=TRUE}
filter(nhanes, sex == "Male")
filter(nhanes, sex == "Male" & plasma.glucose > 80)
filter(nhanes, sex == "Male" & !is.na(hba1c))
```

## Pipes

What if you want to select and filter at the same time? There are three
ways to do this: use intermediate steps, nested functions, or pipes.

With intermediate steps, you create a temporary data frame and use
that as input to the next function, like this:

```{r, purl=TRUE}
nhanes2 <- filter(nhanes, sex == "Male")
nhanes3 <- select(nhanes2, sex, age.years, dental.decay.present, hba1c)
nhanes3
```

This is readable, but can clutter up your workspace with lots of
intermediate objects that you have to name individually. With multiple
steps, that can be hard to keep track of.

You can also nest functions (i.e. one function inside of another),
like this:

```{r, purl=TRUE}
nhanes3 <- select(filter(nhanes, sex == "Male"), sex, age.years, dental.decay.present, hba1c)
nhanes3
```

This is handy, but can be difficult to read if too many functions are nested, as
R evaluates the expression from the inside out (in this case, filtering, then selecting).

The last option, *pipes*, are a recent addition to R. Pipes let you take
the output of one function and send it directly to the next, which is useful
when you need to do many things to the same dataset.

Pipes in R look like `%>%` (made available via the **`magrittr`**
package) or `|>` (through base R). If you use RStudio, you can type
the pipe with <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> if you
have a PC or <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> if you
have a Mac.

In the above code, we use the pipe to send the `nhanes` dataset first
through `filter()` to keep rows where `sex` is Male, then through
`select()` to keep only the selected columns.

The pipe `%>%` takes the object on its left and passes it directly as
the first argument to the function on its right, we don't need to
explicitly include the data frame as an argument to the `filter()` and
`select()` functions any more.

```{r, purl=TRUE}
nhanes %>%
  filter(sex == "Male") %>%
  select(sex, age.years, dental.decay.present, hba1c)
```

Some may find it helpful to read the pipe like the word "then". For instance,
in the above example, we took the data frame `rna`, *then* we `filter`ed
for rows with `sex == "Male"`, *then* we `select`ed columns `sex`, `age.years`, `dental.decay.present`, and `hba1c`.

The **`dplyr`** functions by themselves are somewhat simple, but by
combining them into linear workflows with the pipe, we can accomplish
more complex manipulations of data frames.

If we want to create a new object with this smaller version of the data, we
can assign it a new name:

```{r, purl=TRUE}
nhanes3 %>%
  filter(sex == "Male") %>%
  select(sex, age.years, dental.decay.present, hba1c)

nhanes3
```

::: {.callout-note icon=false}

## Challenge:

Using pipes, subset the `nhanes` data to keep female participants 15 years or older,
where the hba1c is greater than 5.2 (and is not `NA`), and retain only the columns `sex`, `age.years`, and `plasma.glucose`.

:::

::: {.callout-tip icon=false collapse=true}

## Solution

```{r}
nhanes %>%
  filter(hba1c > 5.2,
         sex == "Female",
         age.years >= 15 ) %>%
  select(sex, age.years, plasma.glucose)
```
:::

# Summarizing Data in Tables

```{r}
#| label: preview-data
#| echo: false
#| message: false

nhanes_processed <- read_csv("../data/nhanes_processed.csv")
DT::datatable(head(nhanes_processed,200), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

For some data, we might want to visualize things with a table instead of a plot. 
We can use the `table` builtin function to easily tabulate age by dental caries. 

```{r}
table(nhanes_processed[,c("RIDAGEYR","dental.caries")])
```
However, we can also take advantage of packages written for this purpose. 
For instance, we can quickly make a frequency table using the `proc_freq` function in `flextable`. 

```{r}
# install.packages("flextable")
library(flextable)
proc_freq(nhanes_processed,"RIDAGEYR","dental.caries")
```

Or we can use the `gtsummary` package to summarize everything.

```{r}
library(gtsummary)

select(nhanes_processed,dental.caries, age.cat, bmi.cat, hba1c.cat, birthplace, diabetes) %>%
  tbl_summary(by = dental.caries)
```

# Visualizing Data

## First steps with ggplot2 

**ggplot2** is the most popular data visualisation R package. Its `ggplot()` function is at the core of this package, and this whole approach is colloquially known as *"ggplot"* with the resulting figures sometimes affectionately called "ggplots". The "gg" in these names reflects the "**g**rammar of **g**raphics" used to construct the figures. **ggplot2** benefits from a wide variety of supplementary R packages that further enhance its functionality.

The [data visualization with ggplot cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) from the RStudio website is a great reference to have on-hand when creating pltos. If you want inspiration for ways to creatively visualise your data, we suggest reviewing websites like the [R graph gallery](https://www.r-graph-gallery.com/) and [Data-to-viz](https://www.data-to-viz.com/caveats.html).

We can summarize the ggplot approach as:

```r
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

Where we define a dataset, choose which variables map to which aspects of the plot, and then choose the `geom()` or type of plot to draw. 

Let's plug the NHANES dataset into a plot. 

```{r}
nhanes <- read_csv("../data/week2Data.csv")
ggplot(nhanes) # <1>
```
1. `data` and `mapping` are positional arguments in the `ggplot` function, so we don't have to name them. However, it can be good practice to include the argument names so that it's immediately obvious what each argument is. 


Since we haven't told `ggplot` what we want to display, we just get a blank plot.
If we add some mappings for the x and y axes:

```{r}
ggplot(nhanes, aes(x = hba1c, y = plasma.glucose))
```
We now get labeled axes and scales based on the variable range. 
Finally, we can add a `geom()`.
Let's make a scatterplot, created with `geom_point()` in ggplot. 

```{r}
ggplot(nhanes, aes(x = hba1c, y = plasma.glucose)) +
  geom_point()
```
Now, let's make a boxplot showing how BMI varies by subject ethnicity. 
Inside of the `geom_boxplot` function, we'll also set the `varwidth` parameter to true so that the box sizes vary with how many samples are in each category.

```{r}
ggplot(nhanes, aes(x = ethnicity, y = bmi)) + 
  geom_boxplot(varwidth = TRUE)
```

::: {.callout-tip appearance="minimal"}
## Exercise
Instead of a boxplot, try making a bee swarm plot or a violin plot. 
Note that the beeswarm plot is in a separate package, `ggbeeswarm`.
You might need to vary the `cex` argument in the beeswarm plot to increase the spacing between the strips. 

```{r}
# install.packages("ggbeeswarm")
library(ggbeeswarm)
#TODO your plot here

# Beeswarm plot
ggplot(nhanes, aes(x = ethnicity, y = bmi)) + 
  geom_beeswarm(cex = 0.5)

# Violin plot
ggplot(nhanes, aes(x = ethnicity, y = bmi)) + 
  geom_violin()
```
:::

Note that we can also easily make boxplots using R's builtin plotting `boxplot` function. 

```{r}
boxplot(bmi ~ ethnicity, data = nhanes)
```

## Mapping Variables

Beyond the actual axes we can use mappings to encode variables as various aspects of a plot. Some of the most commonly used other mapping types are `shape`, `fill`, `color`, `size`, and `linetype`.

For instance, let's take our scatterplot from before and color the points by diabetic status. 

```{r}
ggplot(nhanes, aes(x = hba1c, y = plasma.glucose, color = diabetes)) +
  geom_point() 
```
It is difficult to tell how many diabetic participants are in this plot, as it's possible that the red diabetic points have been covered by the blue and green points. 
We can alter the transparency of the points by changing `alpha`. 
Remember we can also change parts of the plot outside of `aes()` to have them not depend on any variable. 

```{r}
ggplot(nhanes, aes(x = hba1c, y = plasma.glucose, color = diabetes)) +
  geom_point(alpha = 0.6) 
```
We can also have a single variable encoded into multiple parts of the plot.

```{r}
ggplot(nhanes, aes(x = hba1c, y = plasma.glucose, color = diabetes, shape = diabetes)) +
  geom_point(alpha = 0.6) 
```
::: {.callout-tip appearance="minimal"}
## Exercise
a. Try coloring your boxplot from before by `age.years`. What happens? What about when you use `age.cat`? *Remember to use `fill` instead of `color` for shapes like boxplots.*

```{r}
# We can't color by age since it's numeric, ggplot gives an error. 
ggplot(nhanes, aes(x = ethnicity, y = bmi, fill = age.years)) + 
  geom_boxplot()
```
```{r}
ggplot(nhanes, aes(x = ethnicity, y = bmi, fill = age.cat)) + 
  geom_boxplot()
```
b. Now try flipping which variables are encoded in `x` and `fill`. Which version do you think works better?

```{r}
ggplot(nhanes, aes(x = age.cat, y = bmi, fill = ethnicity)) + 
  geom_boxplot()
```
:::



## Customizing Plots

Taking a figure all the way to publication-quality can require careful fine tuning. 
ggplot has a variety of useful themes and other ways to improve a figure's appearance and readability. 

Here's an example of some of what you can do.
Note that changing the `fig.width` setting for the code block will not effect how the image looks when exported. 

```{r}
#| fig.width: 10
#Maybe we want a color scheme from a Wes Anderson movie:
library(wesanderson)

#Note that this font import can take multiple minutes to run
pal <- wes_palette("Zissou1", 2, type = "continuous")

ggplot(nhanes, aes(x = ethnicity, y = bmi, fill = dental.caries)) + 
 geom_boxplot() +
 theme_minimal() +
 ggtitle("BMI by ethicity and dental caries") +
 xlab("Ethnicity") +
 ylab("BMI") +
 scale_fill_manual(values = pal, name = "Dental Caries") +
 theme(text = element_text(size=14), axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```
::: {.callout-tip appearance="minimal"}
## Exercise

Use a figure you've already created, or choose a new plot to create. 
Try to get that figure to as close to publication-ready as possible. 
The [R Graph Gallery](https://r-graph-gallery.com/) is a great place to look for inspiration on what you can do to improve your plots. 

If there's something you want to change but don't know how, try checking the [ggplot2 cheatsheet](https://rstudio.github.io/cheatsheets/html/data-visualization.html), the [extended ggplot chapter](https://epirhandbook.com/en/ggplot-basics.html), and the [official documentation](https://ggplot2.tidyverse.org/).  

```{r}
# TODO your plotting code here
```
:::

## Creating maps and using shape files

As with everything else, there are a variety of ways to create maps in R. Let's look at 2 examples, creating simple maps with the `maps` package and importing a shapefile using the `sf` package. 

For simple information we want to see on a standard map, we can use the `maps` package. 
For instance, we can grab a map of the USA and plot some coordinates.

```{r}
library(maps)
library(ggmap)
library(mapdata)
library(tmap)

usa <- map_data("usa") 

labs <- data.frame(
  long = c(-122.064873, -122.306417),
  lat = c(36.951968, 47.644855),
  names = c("SWFSC-FED", "NWFSC"),
  stringsAsFactors = FALSE
  )  

ggplot() +
  geom_polygon(data = usa, aes(x=long, y = lat, group = group), fill = "coral", color = "brown") + 
  coord_fixed(1.3) +
  geom_point(data = labs, aes(x = long, y = lat), color = "black", size = 5) +
  geom_point(data = labs, aes(x = long, y = lat), color = "gold", size = 4)
```
Or we can get data for states

```{r}
states <- map_data("state")
head(states)
```

And then grab and plot just new england. 

```{r}
new_england <- subset(states, region %in% c('connecticut', 'maine', 'massachusetts', 'new hampshire', 'rhode island', 'vermont'))

ggplot(data = new_england) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "palegreen", color = "black") + 
  coord_fixed(1.3)
```
Let's zoom in and plot population density by county in CT. 

```{r}
ct_df <- subset(states, region == "connecticut")

counties <- map_data("county")
ct_county <- subset(counties, region == "connecticut")
```

We start by plotting just the state boundaries. Let's get rid of the background gridlines too. 

```{r}
ct_base <- ggplot(data = ct_df, mapping = aes(x = long, y = lat, group = group)) + 
  coord_fixed(1.3) + 
  geom_polygon(color = "black", fill = "gray")
ct_base + theme_nothing()
```

Now we can add the county borders in white. 

```{r}
ct_base + theme_nothing() + 
  geom_polygon(data = ct_county, color = "white", aes(fill = subregion))
```
```{r}
library(sf)

linelist <- readRDS("../data/linelist_cleaned.rds")

# generate 1000 random row numbers, from the number of rows in linelist
sample_rows <- sample(nrow(linelist), 1000)

# subset linelist to keep only the sample rows, and all columns
linelist <- linelist[sample_rows,]
```

We use the package `sf` (spatial features) and its function `st_as_sf()` to create the new object we call `linelist_sf`. This new object looks essentially the same as the `linelist`, but the columns `lon` and `lat` have been designated as coordinate columns, and a coordinate reference system (CRS) has been assigned for when the points are displayed. 

```{r}
linelist_sf <- linelist %>%
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)

datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

```{r}
sle_adm3_raw <- read_sf("../data/gis/sle_adm3.shp")

# ADM3 level clean
sle_adm3 <- sle_adm3_raw %>%
  janitor::clean_names() %>% # standardize column names
  filter(admin2name %in% c("Western Area Urban", "Western Area Rural")) # filter to keep certain areas
```

The package `tmap` offers simple mapping capabilities for both static (“plot” mode) and interactive (“view” mode) with just a few lines of code. 
We can plot the distribution of ebola cases using `tmap`.

```{r}
tmap_mode("plot") # choose either "view" or "plot"
tm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')
```
This is not very useful without the administrative border data. 

```{r}
tmap_mode("plot") # choose either "view" or "plot"
tm_shape(sle_adm3,               # admin boundaries shapefile
           bbox = c(-13.3, 8.43,  # corner
                  -13.2, 8.51)) +   # corner
  tm_polygons(col = "#F7F7F7")+    # show polygons in light grey
  tm_borders(col = "#000000",      # show borders with color and line weight
             lwd = 2) +
  tm_text("admin3name")   +         # column text to display for each polygon
  tm_shape(linelist_sf) +
  tm_dots(size=0.08, col='blue', alpha = 0.5) +
  tm_layout(title = "Distribution of Ebola cases")   # give title to map
```

John A. Graves has a great example analysis in R using the Dartmouth atlas data to examine different definitions of health care markets which you can find [here](https://github.com/graveja0/health-care-markets).  

## Exporting plots

Exporting ggplots is made easy with the `ggsave()` function from **ggplot2**. It can work in two ways, either:

-   Specify the name of the plot object, then the file path and name with extension
    -   For example: `ggsave(my_plot, "plots/my_plot.png"))`\
-   Run the command with only a file path, to save the last plot that was printed
    -   For example: `ggsave("plots/my_plot.png"))`

You can export as png, pdf, jpeg, tiff, bmp, svg, or several other file types, by specifying the file extension in the file path.

You can also specify the arguments `width =`, `height =`, and `units =` (either "in", "cm", or "mm"). You can also specify `dpi =` with a number for plot resolution (e.g. 300). See the function details by entering `?ggsave` or reading the [documentation online](https://ggplot2.tidyverse.org/reference/ggsave.html).

------------------------------------------------------------------------

*The materials in this lesson have been adapted from work created by the (HBC)\](http://bioinformatics.sph.harvard.edu/) and Data Carpentry (http://datacarpentry.org/), as well as materials created by Laurent Gatto, Charlotte Soneson, Jenny Drnevich, Robert Castelo, and Kevin Rue-Albert. These are open access materials distributed under the terms of the [Creative Commons Attribution license](https://creativecommons.org/licenses/by/4.0/) (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.*